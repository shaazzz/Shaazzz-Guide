--- 
hide:
  - footer
---
# مرتب سازی

## توضیحات 
مسئله‌ی مرتب سازی (Sort)، مسئله‌ای به ظاهر ساده و بسیار کربردی است. در این مسئله یک مجموعه از اعضای مشخصی که قابل مقایسه باشند، داده می‌شوند و می‌خواهیم آن‌ها را به ترتیب از کوچک به بزرگ مرتب کنیم. راه های زیادی برای این مسئله وجود دارد که در این بخش به بررسی چند مورد از معروف ترین روش های مرتب سازی خواهیم پرداخت. البته خوشبختانه ++C تابع خوبی برای سورت کردن یک مجموعه دارد، اما با این حال درک الگوریتم‌های معروف مرتب سازی هم خالی از لطف نبوده و ممکن است برای حل بعضی مسائل مورد استفاده قرار گیرند. 

عموما در این مسئله ترتیب اعضای مساوی اهمیتی ندارد و در واقع این اعضا کاملا یکسان در نظرگرفته می‌شوند. با این حال گاهی اوقات اعضا کاملا یکسان نیستند، و صرفا ممکن است در نحوه‌ی مقایسه‌ی تعریف شده، مساوی تعریف شوند. مرتب سازی پایدار (Stable sort) به نحوه‌ای از مرتب سازی گفته می‌شود که اعضای مساوی را به ترتیب ورودی میچیند.

!!! warning ""

    کد و الگوریتم‌های زیر به توضیح چگونگی سورت کردن یک آرایه از 
    `#!cpp int`
    پرداخته‌اند. اما به سادگی می‌توان دید به ازای هر آرایه از جنس متغییرهایی که قابل مقایسه باشند، الگوریتم‌ها درست و امکان پذیر هستند.


### اینزرشن سورت

اینزرشن سورت (Insertion sort) الگوریتمی برای مرتب سازیست که در تایم $O(n ^ 2)$ و مموری $O(n)$ اجرا می‌شود.

#### الگوریتم

می‌خواهیم آرایه $A$ به طول $n$ را سورت کنیم. در طی $n$ مرحله $A$ را سورت می‌کنیم به طوری که بعد از مرحله $i$ام، $i$ عضو اول دنباله مرتب شده باشند. مرحله $i + 1$ام به این صورت است:

پوینتر $pt$ را روی خانه $i$ام می‌گذاریم و تا وقتی که از آرایه خارج نشدیم این عملیات را تکرار می‌کنیم:

1. اگر $a_{pt} ≤ a_{pt + 1}$ این مرحله را تمام کن.

2. مقدار $a_{pt}$ و $a_{pt + 1}$ را با هم جا‌به‌جا کن.

3. از $pt$ یکی کم کن.

??? success "اثبات درستی الگوریتم"

	روی $i$ استقرا می زنیم. می‌خواهیم ثابت کنیم اگر پس از مرحله $i$ام، $i$ عضو اول دنباله مرتب شده باشند، آنگاه پس از $i + 1$امین مرحله $i + 1$ خانه اول آرایه مرتب شده‌اند.

	اگر فرض کنیم $a_{i + 1}$ برابر $x$ باشد، می‌خواهیم عدد $x$ را به $i$ عدد اول آرایه که مرتب شده هستند اضافه کنیم. در اولین عملیات $a_{pt + 1}$ همان $x$ است که می‌خواهد به آرایه اضافه شود و هر بار که یک عملیات به طور کامل اجرا می‌شود این شرط درست باقی می‌ماند، که یعنی هر بار عملیات جایگاه $x$ را نسبت به $i$ عدد اول آرایه یکی عقب می‌آورد. $x$ از سافیکسی از $i$ عدد اول کوچکتر است، اگر اندازه این سافیکس $t$ باشد، آنگاه دقیقا $t$ عملیات کامل انجام می‌شوند.
	
	حداکثر $t$ عملیات انجام می‌شود چون پس از $t$امین مرحله یا $pt$ از آرایه خارج شده است یا به آخرین عضو پریفیکسی رسیدیم که از $x$ کوچکتر یا مساوی هستند و عملیات متوقف می‌شود.

	حداقل $t$ عملیات انجام می‌شود چون همه اعداد سافیکس از $x$ بزرگترند پس در حین $t$ عملیات اول هیچوقت شرط قسمت اول عملیات‌ها درست نیست.
	
	 پس $x$ بین سافیکس اعدادی که از آنها کوچکتر است و پریفیکس اعدادی که از آنها بزرگتر یا مساوی است قرار می‌گیرد، که یعنی $i + 1$ عدد اول آرایه مرتب شده‌اند.

<figure markdown>
  ![Insertion-sort-example.gif](https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif)
  <figcaption> الگوریتم اینزرشن سورت </figcaption>
</figure>

#### پیچیدگی زمانی

این الگوریتم $n$ مرحله دارد و در هر مرحله حداکثر $n$ عملیات انجام می‌دهیم، پس تایم الگوریتم از $O(n ^ 2)$ است.

|  | زمان الگوریتم   |
| ---------: | :---------------------: |
| بدترین حالت     |  $O(n ^ 2)$ |
| میانگین حالات | $O(n ^ 2)$ |
| بهترین حالت | $O(n)$ |

#### کد

``` cpp linenums="1"

int a[maxn];

for(int i = 0 ; i < n ; i++){
	int pt = i;
	while(pt > -1){ // (1)!
		if(a[pt] <= a[pt + 1]) break; // (2)!
		swap(a[pt] , a[pt + 1]);
		pt--;
	}
}

```

1. تا وقتی که از آرایه خارج نشدی، این عملیات را تکرار کن.

2. اگر $a_{pt} ≤ a_{pt + 1}$ آنگاه $x$ بین سافیکسی که از آنها کوچکتر است و پریفیکسی که از آنها بزرگتر یا مساوی است قرار گرفته است.

### مرج سورت

مرج سورت (Merge Sort) یا مرتب سازی ادغامی، یک روش برای سورت کردن است که به نسبت روش‌های قبلی زمان اجرای بهتری دارد و از اردر $O(n log_n)$ تایم و $O(n)$ مموری قابل پیاده‌سازی است. این سورت به صورت بازگشتی هست و از تریک Divide & Conquer استفاده می‌کند. 

#### الگوریتم

می‌خواهیم تابع 
`#!cpp void merge_sort(int *A, int l, int r)`
 را پیاده سازی کنیم که بازه‌ی $[l, r)$ از آرایه $A$ را سورت کند. $(2 \leq r - l)$ ابتدا آرایه را به دوبخش به طول های $\lfloor \frac{r - l}{2} \rfloor$ و $\lceil \frac{r - l}{2} \rceil$ تقسیم می‌کنیم و به صورت بازگشتی سورت می‌کنیم. سپس دو بخش سورت شده را ادغام می‌کنیم. (دو بخش $[l, \lfloor \frac{r - l}{2} \rfloor)$ و $[\lfloor \frac{r - l}{2} \rfloor, r)$) می‌خواهیم آرایه‌ی ادغام شده را در آرایه‌ی  $r - l$ عضوی $B$ بریزیم.

برای این‌ کار، دو پوینتر در نظر می‌گیریم که در ابتدا یکی روی عضو اول بخش اول و دیگری روی عضو اول بخش دوم قرار دارد. تا زمانی که هر دو پوینتر درون بخش ها هستند، از بین دو عضوی که پوینتر ها در حال اشاره کردن به آن‌ها هستند،‌ عضو کوچک تر را در انتهای آرایه $B$ قرار می‌دهیم (اگر هر دو عضو برابر بودند، به دلخواه یکی را می‌گذاریم) و آن پوینتر را جلو می‌بریم. اگر یکی از پوینتر ها از بخش خودش خارج شد (به عبارتی اگر تمام اعضای آن بخش را در آرایه‌ی $B$ قرار داده بودیم) در آن صورت به ترتیب اعضای بخش دیگر را از جایگاه فعلی پوینترش تا آخر در آرایه‌ی $B$ قرار می‌دهیم. در آخر به ترتیب مقادیر $B$ را در $A_l \dots A_{r - 1}$ قرار می‌دهیم و آرایه‌ی $B$ را پاک می‌کنیم.

??? success "اثبات درستی الگوریتم"

    استقرای قوی می‌زنیم روی مقدار $r - l$ و به کمک آن ثابت می‌کنیم الگوریتم درست است. 

    پایه: $r - l = 1$ ،‌ اگر طول بازه‌ای که می‌خواهیم سورت کنیم برابر با ۱ باشد، بازه سورت شده است و نیازی به تغییر ندارد.

    فرض کنید به ازای تمام مقادیر کمتر از $r - l$ الگوریتم درست باشد،‌ برای این مقدار ثابت می‌کنیم.

    طبق فرض استقرا دو بخشی که به صورت بازگشتی سورت می‌شوند به درستی سورت خواهند شد. در بخش مرج شدن، به کمک برهان خلف ثابت می‌کنیم الگوریتم درست است. فرض کنید در انتها دو اندیس ‌$i$ و $j$ وجود داشته باشند به طوری‌که $i < j$ و $B_i > B_j$. قطعا این دو عضو از یک بخش نبودند،‌زیرا هر بخش بین خودش سورت شده بود. بدون از دست دادن کلیت مسئله فرض می‌کنیم عضو $i$ از بخش اول بوده‌است. زمانی که ما این عضو را در آرایه‌ی $B$ گذاشتیم، پوینتر بخش دوم قطعا از بخشش خارج نشده بود و صرفا به عضوی بیشتر مساوی عضو نشان داده شده در بخش اول، اشاره داشت. (فرض کنید این مقدار از بخش دوم $w$ باشد) همچنین قطعا پوینتر بخش دوم از عضوی که در $B_j$ قرار داده شده‌است، نگذشته بود. و چون بخش دوم بین خودش سورت شده است: 

    $$B_i \leq w, \ w \leq B_j \Longrightarrow B_i \leq B_j$$

    که با فرض ما در تناقض است و در نتیجه الگوریتم درست کار می‌کند.


#### پیچیدگی زمانی

اگر $T(n)$، زمان مورد نیاز برای حل مسئله در آرایه به طول $n$ باشد،‌ داریم:

$$T(1) = O(1)$$

$$T(n) = 2 \times T(\frac{n}{2}) + O(n)$$

اگر تابع بازگشتی را به شکل یک درخت ببینیم، که ریشه‌ی درخت نماینده تابع مرج سورت برای $[0, n)$ باشد و بچه‌ی راس $[l, r)$، دو تابعی بشود که توسط این راس صدا شده است، می‌توان دید مجموع طول بازه‌های راس‌های یک طبقه، کمتر مساوی $n$ است. این درخت از $O(log_n)$ طبقه دارد. (زیرا در هر مرحله اگر طول بازه $len$ باشد، در بدترین حالت، به $\lceil \frac{len}{2} \rceil$ تبدیل می‌شود. و فقط تا زمانی که به ۱ برسد ادامه دارد، پس می‌شود $log_n + O(1)$) هر طبقه از $O(n)$ هزینه می‌دهد. پس در کل الگوریتم ما از $O(n log_n)$ اجرا می‌شود. حتی می‌توان ثابت کرد الگوریتم مرج سورت از $\Theta(n log_n)$ هم هست.


<figure markdown>
  ![image.png](https://i.postimg.cc/qRCWtMn6/image.png)
  <figcaption>درخت توابع مرج سورت</figcaption>
</figure>


#### کد

``` cpp linenums="1"

int B[maxn];

void merge_sort(int *A, int l, int r){
    if(r - l == 1) // (1)!
        return;
    int mid = (l + r) >> 1;
    merge_sort(A, l, mid);
    merge_sort(A, mid, r);
    int pt1 = l, pt2 = mid, ptB = 0;
    while(pt1 < mid || pt2 < r){ // (2)!
        if(pt1 < mid && (pt2 == r || A[pt1] < A[pt2])) // (3)!
            B[ptB++] = A[pt1++];
        else
            B[ptB++] = A[pt2++];
    }
    for(int i = r - 1; i >= l; i--)
        A[i] = B[--ptB];
}
```

1.	در صورتی که طول بازه‌ی مد نظر برای سورت کردن،‌ ۱ باشد، بدون هیچ تغییری خارج می‌شود.

2.	تا زمانی که هنوز تمام $r - l$ عضو را ندیده‌ایم ادامه می‌دهد.

3.	در این قسمت، اگر یکی از بخش ها تمام شده باشند، قطعا یک عضو از بخش دیگر برداشته خواهد شد. در غیر این صورت اگر عضو بخش اول کوچک‌تر از بخش دوم باشد، عضو بخش اول قرار داده می‌شود و در غیر این صورت از بخش دوم بر‌ می‌دارد.

!!! warning ""
    تابع 
    ‍`#!cpp std::merge` 
     دو بازه‌ی سورت شده می‌گیرد و این دو بازه را ادغام می‌کند. می‌توانید از این تابع هم در مرج سورت استفاده کنید. [نحوه‌ی دقیق کارکرد و اطلاعات بیشتر](https://en.cppreference.com/w/cpp/algorithm/merge).

#### مسئله‌ی نابه‌جایی‌ها

یک آرایه $n$ ($n \leq 10^6$) عضوی از اعداد داریم. تعداد نابه‌جایی‌های این آرایه را بیابید. ([لینک سوال](https://codeforces.com/problemsets/acmsguru/problem/99999/180))

??? question "نابه‌جایی چیست؟"

	نابه‌جایی (Inversion) در آرایه $A$، یک پیر از اندیس‌هایی مانند $i$ و $j$ است به صورتی که $i < j$ و $A_i > A_j$ باشد.

??? tip "راهنمایی"

    الگوریتم مرج کردن را در نظر بگیرید و سعی کنید تعداد نابه‌جایی‌های بین بخش اول با بخش دوم را بدست آورید.

??? success "راه حل"

	برای حل این مسئله از تکنیک تقسیم و حل و الگوریتم مرج سورت استفاده می‌کنیم. فرض کنید در طی الگوریتم مرج سورت به صورت بازگشتی، تعداد نابه‌جایی‌های درون بخش اول و درون بخش دوم را بدست آورده‌ایم، تعداد نابه‌جایی‌های بین بخش اول و دوم را می‌خواهیم. الگوریتم مرج را در نظر بگیرید، فرض کنید اگر عضوی از بخش اول که به آن اشاره شده‌است مساوی با عضو از بخش دوم بود، عضو بخش اول را در $B$ قرار خواهیم داد. زمانی که یک عضو را از بخش اول در آرایه‌ی $B$ قرار می‌دهیم، این عضو از تمام اعضایی که در $B$ هستند و از بخش دوم بودند اکیدا بزرگ‌تر بوده و با آن‌ها نابه‌جایی می‌سازد. تعداد این اعضا برابر است با $pt2 - mid$ که $pt2$ پوینتر مربوط به بخش دوم است و $mid = \lfloor \frac{r - l}{2} \rfloor$ است. (بخش دوم از $mid$ شروع شده‌است) الگوریتم ما دقیقا مشابه تحلیل اردر مرج سورت، از $O(n log_n)$ هزینه می‌برد که مطلوب است.

### کوئیک سورت

کوئیک سورت (‌Quick sort)، یک روش مرتب سازی با پیچیدگی زمانی $O(n^2)$ و مموری $O(n)$ است که البته از لحاظ زمانی این سورت با تغییرات جزئی قادر به رسیدن به پیچیدگی زمانی $O(n \log n)$ است.

#### الگوریتم
در این روش مرتب سازی ابتدا یک عضو از آرایه را در نظر میگیریم
$(x)$
. می دانیم باقی اعضای آرایه یا از 
$x$
 کمتر مساوی هست و یا بیشتر اکید و همچنین می دانیم در آرایه مرتب شده نهایی تمام کسانی که بیشتر اکید هستند بعد از تمام کسانی می آیند که کمتر و یا مساوی هستند در واقع اگر مجموعه اعداد بیشتر از 
 $x$
  را 
  $More(x)$
   و کمتر مساوی آن را 
  $Less(x)$
   بنامیم آرایه مرتب شده نهایی به شکل

$Sorted(Less(x)) \; , \; x \; , \; Sorted(More(x))$

حال کافی است
 $Less(x)$ 
 و 
 $More(x)$ 
را جدا کرده به صورت بازگشتی مرتبشان کنیم و در نهایت در آرایه نهایی  به ترتیب گفته شده بچینیم.

!!! نکته
     در برخی منابع به 
    $x$
    $،$
    $pivot$
    گفته می شود.
#### پیچیدگی زمانی
$T(N)$
را تعداد عملیات های لازم برای مرتب کردن یک آرایه 
$N$
عضوه در نظر بگیرید. هدف این است که اثبات کنیم اگر 
$x$
را به صورت رندوم از اعضای آرایه انتخاب کنیم در بدترین حالت 
${T(N)} \in {O(N^2)}$
از استقرا استقاده میکنیم و پایه استقرا را 
$N \leq 1$
قرار میدهیم.
برای گام استقرا میدانیم

$$T(N) = T(L) + T(M) + c \times N$$

به نحوی که 
$L+M = N-1$ و 
$c$
عددی ثابت باشد.

حال بدون کم شدن از کلیت فرض کنید. 
$L < M$
آنگاه بدست می آید

$${T(N)} \geq {T(M) + c \times N}$$

که اگر 
$M = N-1$
باشد عضو 
$O(N^2)$
است.

البته اگر 
$x$
را رندوم بگیریم و رندوممان خوب باشد امید ریاضی پیچیدگی زمانی مان 
$O(n \log n)$
است و اگر 
$x$
را برای مثال میانه آرایه مان قرار دهیم باز هم پیچیدگی زمانی مان
$O(n \log n)$
است. برای توضیحات بیشتر به لینک های پیوست مراجعه کنید.

#### کد
``` cpp title="Quick Sort" linenums="1" 
#include <iostream>
#include <random>

using namespace std;

const int maxn = 100005;

int a[maxn],tmp[maxn];

void Quick_Sort(int *a, int l, int r){ // (1)!
    if (r - l <= 1) return;

    int ind = l + rand() % (r - l), pivot = a[ind];
    int less = 0, more = 0;

    for (int i = l; i < r; i++){

        if (i == ind) continue; // (2)!

        if (a[i] <= pivot){ // (3)!
            tmp[l + less] = a[i];
            less++;
        }
        else{ // (4)!
            more++;
            tmp[r - more] = a[i];
        }
    }

    tmp[l + less] = pivot; // (5)!

    for (int i = l; i < r; i++)
        a[i] = tmp[i];
    
    Quick_Sort(a, l, l+less);
    Quick_Sort(a, r-more, r);

    return;
}
```

1. بازه بسته باز

2. $pivot$ را حذف می کنیم به صورت موقت

3. مقادیر کمتر مساوی از سمت چپ در آرایه موقت ظاهر میشوند

4. مقادیر بیشتر از سمت راست در آرایه موقت ظاهر میشوند

5. جایگاه $pivot$

### منابع بیشتر

+ [std::sort](https://en.cppreference.com/w/cpp/algorithm/sort)
+ [Insertion sort](https://www.geeksforgeeks.org/insertion-sort/)
+ [Merge sort](https://www.geeksforgeeks.org/merge-sort/)
+ [Randomized Quick sort](https://towardsdatascience.com/basic-algorithms-quicksort-b549ea9ef27)
+ [Quick sort using median](https://sungwookyoo.github.io/algorithms/QuickSortMedian/)
## سوال ها 
| سوال | سختی | تگ ها | جاج | 
| :-----: | :----: | :----: | :----: | 
|[Subsequence Permutation](https://codeforces.com/problemset/problem/1552/A){:target="_blank"}|800|<details> <summary>Spoiler</summary> <ul><li>[مرتب سازی](/Shaazzz-Guide/Level1/sort){:target="_blank"}</li></ul> </details>|:judge-codeforces: [Codeforces](https://codeforces.com/){:target="_blank"}|
|[Merge Sort](https://www.spoj.com/problems/MERGSORT/){:target="_blank"}|800|<details> <summary>Spoiler</summary> <ul><li>[مرتب سازی](/Shaazzz-Guide/Level1/sort){:target="_blank"}</li></ul> </details>|:judge-spoj: [Spoj](https://spoj.com/){:target="_blank"}|
|[Distinct Numbers](https://cses.fi/problemset/task/1621){:target="_blank"}|900|<details> <summary>Spoiler</summary> <ul><li>[مرتب سازی](/Shaazzz-Guide/Level1/sort){:target="_blank"}</li></ul> </details>|:judge-cses: [CSES](https://cses.fi){:target="_blank"}|
|[Subarray Sums II](https://cses.fi/problemset/task/1661){:target="_blank"}|1100|<details> <summary>Spoiler</summary> <ul><li>[پریفیکس سام](/Shaazzz-Guide/Level1/prefix_sum){:target="_blank"}</li> <li>[مرتب سازی](/Shaazzz-Guide/Level1/sort){:target="_blank"}</li></ul> </details>|:judge-cses: [CSES](https://cses.fi){:target="_blank"}|
|[out of sorts](http://www.usaco.org/index.php?page=viewproblem2&cpid=834){:target="_blank"}|1400|<details> <summary>Spoiler</summary> <ul><li>[مرتب سازی](/Shaazzz-Guide/Level1/sort){:target="_blank"}</li></ul> </details>|:judge-usaco: [Usaco](https://usaco.org){:target="_blank"}|
|[Gluttony](https://codeforces.com/problemset/problem/892/D){:target="_blank"}|2000|<details> <summary>Spoiler</summary> <ul><li>[مرتب سازی](/Shaazzz-Guide/Level1/sort){:target="_blank"}</li></ul> </details>|:judge-codeforces: [Codeforces](https://codeforces.com/){:target="_blank"}|
|[Cow Photography](http://www.usaco.org/index.php?page=viewproblem2&cpid=100){:target="_blank"}|2500|<details> <summary>Spoiler</summary> <ul><li>[مرتب سازی](/Shaazzz-Guide/Level1/sort){:target="_blank"}</li></ul> </details>|:judge-usaco: [Usaco](https://usaco.org){:target="_blank"}|
